# 指针

c语言中的指针是一种特殊的变量，它储存的值是一个内存中的地址，我们可以用这个地址来访问内存中的值。

## 地址

地址，即一个变量在内存中的位置，在32位系统中，地址占4字节，在64位系统中，地址占8字节。

有两个地址运算符：`&` 和 `*` 

前者用于获取一个变量的地址，后者用于获取指针变量所指向的内存地址的值。

```c
int a = 10;
printf("a\'s address is %p\n", &a); // 输出 a 的地址
// %p 以指针形式输出
// a's address is 0x7ffce1a0d014
```

## 声明一个指针

声明一个指针变量，需要在类型名后面加上 `*`

```c
int* p = NULL; // 声明一个指针变量 p
// 或者int *p;
int a = 10;
p=&a; // 将 a 的地址赋值给 p
printf("p points to %d\n", *p); // 输出 p 指向的内存地址的值
// p points to 10
```

还有一种指针，函数指针，它指向一个函数的地址。其声明为：

```c
return_type (*pointer_name)(parameter_type_list);
```
类型即为
```c
return_type (*)(parameter_type_list);
```

下面是一个例子


```c
int add(int a, int b){
    return a+b;
}

int sub(int a, int b){
    return a-b;
}

int main(){
    int (*p)(int, int); // 声明一个指向函数的指针变量 p
    p = add; // 将 add 函数的地址赋值给 p
    printf("%d\n", p(2, 3)); // 输出 p 指向的函数的返回值
    // 5
    p = sub; // 将 sub 函数的地址赋值给 p
    printf("%d\n", p(2, 3)); // 输出 p 指向的函数的返回值
    // -1
    return 0;
}
```


在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 `NULL` 值是一个良好的编程习惯。赋为 `NULL` 值的指针被称为空指针。这是为了防止该指针由于初始的随机值而访问到未知的内存地址，造成不可预估的结果。访问空指针会导致程序崩溃，而不是不可预期的结果。

## 指针与数组

注意：C语言中，优先级：`()` > `[]` > `*`

### 数组指针

```c
char str[] = "hello world";
char* p = str; // 声明一个指针变量 p 指向数组 str 
//(数组名==数组第一个元素的地址)
// 等价于 char* p = &str[0];
printf("%s\n", p); // 输出 p 指向的字符串
// hello world
printf("%c\n", *p); // 输出 p 指向的字符串的第一个字符
// h
printf("%c\n", *(p+1)); // 输出 p 指向的字符串的第二个字符
// e
```

```c
int arr[] = {1, 2, 3, 4, 5};
int* p = arr; // 声明一个指针变量 p 指向数组 arr
printf("%d\n", *(p+2)); // 输出 p 指向的数组的第三个元素
// 3
```

指针的类型不同，其 `+1` 的偏移字符数也不同，通常偏移一个类型的大小。

```c
int (*p)[5]; // 声明一个指向长度为5的数组的指针变量 p
int arr[5] = {1, 2, 3, 4, 5};
p = &arr; // 将 arr 的地址赋值给 p
// p的类型是 int (*)[5], arr的类型为 int[5] 或 int *
// 若使用 p=arr 则会报类型错误的警告
// 但其实 p 指向的地址是 arr 的地址，所以 p 与 arr 在值上相等
printf("%d\n", (*p)[2]); // 输出 p 指向的数组的第三个元素
// 3
```

```c
int (*p)[5];
int arr[10][5]={0};// 声明一个二维数组 arr，其长度为10，每一项的长度为5
// 即 arr[i] 的值为一个长度为5的数组的地址
printf("%p\n",arr[0]);
// 0x7fffe96653b0

// a;//代表数组首行地址，一般用a[0][0]的地址表示
// &a;//代表整个数组的地址，一般用a[0][0]地址表示
// a[i];//代表了第i行起始元素的地址，一般用a[i][0]的地址表示
// &a[i];//代表了第i行的地址，一般用a[i][0]的地址表示
// a[i]+j;//代表了第i行第j个元素地址,a[i]就是j==0的情况
// a[i][j];//代表了第i行第j个元素
// &a[i][j];//代表了第i行第j个元素的地址

p = arr; // 将 arr 的首项的地址赋值给 p
// p的类型是 int (*)[5], arr的类型为 int[10][5] 或 int (*)[5] (即arr第一项的地址)
printf("%d\n", (*p)[2][3]); // 输出 p 指向的数组的第三行第四列元素

p = &arr[2]; // 将 arr 的第三项的地址赋值给 p

printf("%d\n", (*p)[3]); // 输出 p 指向的数组的第四列元素
```



### 指针数组

```c
int* p[5]; // 声明一个指针数组 p，每个元素都是一个指针变量
// 可以理解为数组中每个元素类型为 int*
int arr1[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int arr2[4] = {11, 12, 13, 14};
int arr3[3] = {15, 16, 17};
p[0] = arr1;
p[1] = arr2;
p[2] = arr3;
// +----------------+     
// │ array1_address │----> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
// +----------------+
// │ array2_address │----> {11, 12, 13, 14}
// +----------------+
// │ array3_address │----> {15, 16, 17}
// +----------------+
// │ array4_address │
// +----------------+
// │ array5_address │
// +----------------+
printf("%d\n",p[0][2]);
// 3
printf("%d\n",p[1][1]);
// 12
printf("%d\n",p[2][0]);
// 15
```
### 总结

1.数组指针简单理解为“数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。
2.指针数组简单理解为“指针的数组”，首先这个变量是一个数组，其次，”指针p”修饰这个数组，意思是说这个数组的所有元素都是指针类型。

# 结构体

# 内存管理


# 调试

