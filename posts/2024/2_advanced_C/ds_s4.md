# 数据结构入门：树

Author: [doyo](https://github.com/doyo2024)

## 基本概念

**树（tree）** 是一种非常重要的数据结构。与前面介绍的几种数据结构不同，树是非线性的，也就是说，树中的每个元素都可以链接多个元素。

树的严格定义如下：

> 树是n个结点的有限集，满足：
> 1. 有且仅有一个结点没有前驱结点（**父结点，father或parent**），它称之为这棵树的**根（root）**。
> 2. 除根外，其它每个结点有且仅有一个父结点。 
> 3. 除根外，其它每个结点有且仅有一条路径与根相连；这条路径从根开始，到它结束，并且路径上每个结点都是前一个结点的后继（**子结点，son**）。

容易发现，树中不会出现封闭的回路，并且有n个结点的树总是具有n-1条边。

### 相关术语

除了上文提到的根、父结点、子结点之外，还有下列术语需要注意：

* **叶结点（leaf）**：没有子结点的结点。
* **祖先**：类似于我们日常生活谈论的“祖先”。称结点A是结点B的祖先，如果有一条从A到B的路径，路径上每个结点都是前一个结点的子结点。特别的，根结点是树中其它所有结点的祖先。
* **子树**：以结点A为根的子树是树的一个子集，满足：
    1. A是子树中所有结点的祖先；
    2. 所有以A为祖先的结点都在以A为根的子树中。
* **结点的度**：这个结点具有的子结点的个数。
* **树的度**：树中所有结点度的最大值。
* **结点的层数/高度/深度**：从根结点开始，以根结点为第一层，它的子结点为第二层，以此类推。但另有一些定义以根结点为第零层，这导致算出的层数比这种方式少1。这两种计算方式都是可行的，使用时需要甄别具体语境。
* **树的层数/高度/深度**：树中结点的最大层数。

## 二叉树

二叉树是一种非常特殊的树。二叉树中的每个结点最多仅有两个子结点（分别称为左子结点和右子结点），即二叉树是度不大于2的树。

### 二叉树的基本形态

二叉树有五种基本形态：

* 空二叉树
* 只有一个结点的二叉树
* 只有左子树的二叉树
* 只有右子树的二叉树
* 左右子树都有的二叉树

例如，在下面这棵二叉树中，包含了除空二叉树以外的其它五种形态，你能发现吗？

![img1](/posts/2024/image/ds_s4/tree.png)

### 二叉树的性质

二叉树有许多优美的性质。下面的讨论中，我们默认以根为第1层。

* **性质1：** 二叉树的第 i 层最多有 $2^{i-1}$ 个结点。
* **性质2：** 深度为k的二叉树最少有k个结点，最多有$2^k-1$个结点。
* **性质3：** 有n个叶结点的二叉树，其度为2的非叶结点有n+1个。

### 几种特殊的二叉树

* **满二叉树（Perfect Binary Tree）：** 深度为$k（k >= 1）$、具有$2^k-1$个结点的二叉树。
* **完全二叉树（Complete Binary Tree）：** 从根结点到倒数第二层满足满二叉树的条件，最后一层可以不完全填充，但叶结点都靠左对齐。具有n个结点的完全二叉树深度为$\lfloor log_2n \rfloor$.
* **严二叉树（Full/Proper/Strictly Binary Tree）：** 所有非叶结点度均为2。

### 二叉树的存储

我们可以用类似于链表的方式来存储二叉树：

```c
typedef int ElemType;
struct node {
    int id;                     // 这个结点的id，这个数据不是必须的，此处加上id是为了方便理解
    ElemType data;              // 这个元素所保存的数据
    struct node *lc, *rc;       // 左右儿子指针，分别指向这个节点的左右儿子
};
```

我们可以发现这一结构与链表的结构高度类似，唯一的区别在于指针变成了两个，因为每个结点需要两个不同的指针来分别指向它的左右儿子。

同样的，我们也需要一个指针来指向二叉树的根：

```c
struct node *root;              // 根结点指针
```

### 二叉树的建立

建立一棵二叉树至少需要知道以下信息：

1. 二叉树的根结点在哪里？
2. 每个二叉树结点的左右儿子是什么？

一般情况下，为了叙述方便，我们会为每个结点分配一个从1开始的id，一般以1号结点作为根结点。

构建二叉树的方式与创建链表的方式非常类似，只需注意插入的左右子结点即可。

下面的代码展示了构建二叉树的过程。我们假设每个结点的左右子结点id已被存储在了lchid和rchild这两个数组中。

```c
struct node *build(int id) {
    if (!id) {                      // 按照约定，id为0时代表空结点
        return NULL;
    }
    struct node *now = NewSpace;    // 构建当前结点
    now->id = id;
    now->lc = build(lchild[id]);    // 递归构建左子树
    now->rc = build(rchild[id]);    // 递归构建右子树
}
```

### 二叉树的遍历

二叉树的遍历是指顺着某条搜索路径访问二叉树中的每个结点，使得每个结点恰好被访问一次。这里的“访问”与我们之前介绍的链表的“访问”稍有不同，此处是指对该结点进行的某种操作，比如输出其存储的数据或者修改其中的数据等等。

对于链表等线性的数据结构，讨论遍历是没有意义的。因为它们最多只有一个后继，沿着next指针一直向后跳即可，换言之，它们只有一条搜索路径。

依照结点遍历顺序的不同，二叉树的遍历可以分为三种：

#### 先序遍历(Preorder Traversal, VLR)

也叫先根序，即按照“子树根结点-左子树-右子树”的顺序遍历，可以简记为“根-左-右”。

例如考虑前文图中的那棵二叉树，它的先序遍历经过的节点次序就是：1 2 4 7 3 5 6 8

代码如下：

```c
void preorder(struct node *now) {   
    if (now == NULL) {              // 走到空结点，直接返回
        return;
    }
    printf("%d ", now->id);         // 访问当前结点
    preorder(now->lc);              // 递归访问左子树
    preorder(now->rc);              // 递归访问右子树
}
```

不难发现，按前文所述方法构建二叉树的过程其实也是一种先序遍历。

#### 中序遍历（Inorder Traversal）

也叫中根序，即按照“左子树-子树根结点-右子树”的顺序遍历，可以简记为“左-根-右”。

例如考虑前文图中的那棵二叉树，它的中序遍历经过的节点次序就是：4 7 2 1 5 3 8 6

代码如下：

```c
void inorder(struct node *now) {
    if (now == NULL) {              // 走到空结点，直接返回
        return;
    }
    inorder(now->lc);              // 递归访问左子树         
    printf("%d ", now->id);        // 访问当前结点
    inorder(now->rc);              // 递归访问右子树
}
```

#### 后序遍历（Postorder Traversal，LRD）

也叫后根序，即按照“左子树-右子树-子树根结点”的顺序遍历，可以简记为“左-右-根”。

例如考虑前文图中的那棵二叉树，它的中序遍历经过的节点次序就是：7 4 2 5 8 6 3 1

代码如下：

```c
void postorder(struct node *now) {
    if (now == NULL) {              // 走到空结点，直接返回
        return;
    }
    postorder(now->lc);             // 递归访问左子树
    postorder(now->rc);             // 递归访问右子树
    printf("%d ", now->id);         // 访问当前结点
}
```

#### 扩展到一般的树

对于一般的树，也能进行遍历。但是显然，只能做先序遍历和后序遍历，而不能做中序遍历，因为对于此时每个结点不再只有两个子树，讨论“中”是没有意义的。

